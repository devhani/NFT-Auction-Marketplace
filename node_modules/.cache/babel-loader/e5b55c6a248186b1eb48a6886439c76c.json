{"ast":null,"code":"/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict';\n\nvar multibase = require('multibase');\n\nvar varint = require('varint');\n\nvar _require = require('./constants'),\n    names = _require.names;\n\nvar uint8ArrayToString = require('uint8arrays/to-string');\n\nvar uint8ArrayFromString = require('uint8arrays/from-string');\n\nvar uint8ArrayConcat = require('uint8arrays/concat');\n\nvar codes =\n/** @type {import('./types').CodeNameMap} */\n{}; // eslint-disable-next-line guard-for-in\n\nfor (var key in names) {\n  codes[names[key]] = key;\n}\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\n\n\nfunction toHexString(hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array');\n  }\n\n  return uint8ArrayToString(hash, 'base16');\n}\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Uint8Array}\n */\n\n\nfunction fromHexString(hash) {\n  return uint8ArrayFromString(hash, 'base16');\n}\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\n\n\nfunction toB58String(hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array');\n  }\n\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1);\n}\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Uint8Array} hash\n * @returns {Uint8Array}\n */\n\n\nfunction fromB58String(hash) {\n  var encoded = hash instanceof Uint8Array ? uint8ArrayToString(hash) : hash;\n  return multibase.decode('z' + encoded);\n}\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Uint8Array} bytes\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\n */\n\n\nfunction decode(bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array');\n  }\n\n  if (bytes.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.');\n  }\n\n  var code = varint.decode(bytes);\n\n  if (!isValidCode(code)) {\n    throw new Error(\"multihash unknown function code: 0x\".concat(code.toString(16)));\n  }\n\n  bytes = bytes.slice(varint.decode.bytes);\n  var len = varint.decode(bytes);\n\n  if (len < 0) {\n    throw new Error(\"multihash invalid length: \".concat(len));\n  }\n\n  bytes = bytes.slice(varint.decode.bytes);\n\n  if (bytes.length !== len) {\n    throw new Error(\"multihash length inconsistent: 0x\".concat(uint8ArrayToString(bytes, 'base16')));\n  }\n\n  return {\n    code: code,\n    name: codes[code],\n    length: len,\n    digest: bytes\n  };\n}\n/**\n * Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Uint8Array} digest\n * @param {HashName | HashCode} code\n * @param {number} [length]\n * @returns {Uint8Array}\n */\n\n\nfunction encode(digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code');\n  } // ensure it's a hashfunction code.\n\n\n  var hashfn = coerceCode(code);\n\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array');\n  }\n\n  if (length == null) {\n    length = digest.length;\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.');\n  }\n\n  var hash = varint.encode(hashfn);\n  var len = varint.encode(length);\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length);\n}\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n *\n * @param {HashName | number} name\n * @returns {number}\n */\n\n\nfunction coerceCode(name) {\n  var code = name;\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(\"Unrecognized hash function named: \".concat(name));\n    }\n\n    code = names[name];\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(\"Hash function code should be a number. Got: \".concat(code));\n  }\n\n  if (codes[code] === undefined && !isAppCode(code)) {\n    throw new Error(\"Unrecognized function code: \".concat(code));\n  }\n\n  return code;\n}\n/**\n * Checks if a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\n\n\nfunction isAppCode(code) {\n  return code > 0 && code < 0x10;\n}\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {HashCode} code\n * @returns {boolean}\n */\n\n\nfunction isValidCode(code) {\n  if (isAppCode(code)) {\n    return true;\n  }\n\n  if (codes[code]) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {void}\n * @throws {Error}\n */\n\n\nfunction validate(multihash) {\n  decode(multihash); // throws if bad.\n}\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n * @throws {Error}\n */\n\n\nfunction prefix(multihash) {\n  validate(multihash);\n  return multihash.subarray(0, 2);\n}\n\nmodule.exports = {\n  names: names,\n  codes: Object.freeze(codes),\n  toHexString: toHexString,\n  fromHexString: fromHexString,\n  toB58String: toB58String,\n  fromB58String: fromB58String,\n  decode: decode,\n  encode: encode,\n  coerceCode: coerceCode,\n  isAppCode: isAppCode,\n  validate: validate,\n  prefix: prefix,\n  isValidCode: isValidCode\n  /**\n   * @typedef { import(\"./constants\").HashCode } HashCode\n   * @typedef { import(\"./constants\").HashName } HashName\n   */\n\n};","map":null,"metadata":{},"sourceType":"script"}