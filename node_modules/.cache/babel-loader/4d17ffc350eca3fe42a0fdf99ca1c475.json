{"ast":null,"code":"'use strict';\n\nvar _require = require('ipfs-utils/src/globalthis'),\n    Blob = _require.Blob;\n/**\n * @param {any} obj\n * @returns {obj is ArrayBufferView|ArrayBuffer}\n */\n\n\nfunction isBytes(obj) {\n  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;\n}\n/**\n * @param {any} obj\n * @returns {obj is Blob}\n */\n\n\nfunction isBlob(obj) {\n  return typeof Blob !== 'undefined' && obj instanceof Blob;\n}\n/**\n * An object with a path or content property\n *\n * @param {any} obj\n * @returns {obj is import('./normalise-input').FileInput}\n */\n\n\nfunction isFileObject(obj) {\n  return typeof obj === 'object' && (obj.path || obj.content);\n}\n/**\n * @param {any} value\n * @returns {value is ReadableStream}\n */\n\n\nvar isReadableStream = function isReadableStream(value) {\n  return value && typeof value.getReader === 'function';\n};\n/**\n * @param {any} mtime\n * @returns {{secs:number, nsecs:number}|undefined}\n */\n\n\nfunction mtimeToObject(mtime) {\n  if (mtime == null) {\n    return undefined;\n  } // Javascript Date\n\n\n  if (mtime instanceof Date) {\n    var ms = mtime.getTime();\n    var secs = Math.floor(ms / 1000);\n    return {\n      secs: secs,\n      nsecs: (ms - secs * 1000) * 1000\n    };\n  } // { secs, nsecs }\n\n\n  if (Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    return {\n      secs: mtime.secs,\n      nsecs: mtime.nsecs\n    };\n  } // UnixFS TimeSpec\n\n\n  if (Object.prototype.hasOwnProperty.call(mtime, 'Seconds')) {\n    return {\n      secs: mtime.Seconds,\n      nsecs: mtime.FractionalNanoseconds\n    };\n  } // process.hrtime()\n\n\n  if (Array.isArray(mtime)) {\n    return {\n      secs: mtime[0],\n      nsecs: mtime[1]\n    };\n  }\n  /*\n  TODO: https://github.com/ipfs/aegir/issues/487\n   // process.hrtime.bigint()\n  if (typeof mtime === 'bigint') {\n    const secs = mtime / BigInt(1e9)\n    const nsecs = mtime - (secs * BigInt(1e9))\n     return {\n      secs: parseInt(secs),\n      nsecs: parseInt(nsecs)\n    }\n  }\n  */\n\n}\n/**\n * @param {any} mode\n * @returns {number|undefined}\n */\n\n\nfunction modeToNumber(mode) {\n  if (mode == null) {\n    return undefined;\n  }\n\n  if (typeof mode === 'number') {\n    return mode;\n  }\n\n  mode = mode.toString();\n\n  if (mode.substring(0, 1) === '0') {\n    // octal string\n    return parseInt(mode, 8);\n  } // decimal string\n\n\n  return parseInt(mode, 10);\n}\n\nmodule.exports = {\n  isBytes: isBytes,\n  isBlob: isBlob,\n  isFileObject: isFileObject,\n  isReadableStream: isReadableStream,\n  mtimeToObject: mtimeToObject,\n  modeToNumber: modeToNumber\n};","map":null,"metadata":{},"sourceType":"script"}